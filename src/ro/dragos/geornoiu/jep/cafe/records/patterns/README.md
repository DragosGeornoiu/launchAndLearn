# Factory Methods

URL: https://www.youtube.com/watch?v=1oC9ESbyvqs&list=PLX8CzqL3ArzV4BpOzLanxd4bZr46x5e87&index=14

JEP 395

Declaring a record:

    record Range(int being, int end) {}

The components of the record are compiled as final fields. A record is also final itself so no state can be added by
extending a Record class. A record already extends the class java.lang.Record and it cannot extend another class. Thus
no state can be added to a Record trough inheritance. In a way you could say that the record brakes its encapsulation,
as it exposes its external state.

You cannot instantiate a record without calling its canonical constructor. You can write however your own constructor:
You might want to do this if you want to store defensive copies of the arguments passed.

    record ShoppingCart(List<Product> products) {
        ShoppingCart(List<Product> products) {
            this.product = List.copyOf(products);
        }
    }

Or if you want to validate arguments and prevent creation in certain cases:

    record Range(int begin, int end) {
        Range(int being, int end) {
            if (begin > end) {
                throw new IllegaArgumentException("Begin is greater than end");
            }
            
            this.begin = begin;
            this.end = end;
        }
    }

The compiler will not allow you to not initialise all fields of your record in the constructor. There is however another
way where you do not have to explicitly initialise the fields, when you use the compact constructor:

    record Range(int begin, int end) {
        Range {
            if (begin > end) {
                throw new IllegaArgumentException("Begin is greater than end");
            }
        }
    } 

toString(), equals() and hashcode() are also generated by the compiler For all three methods, the bytecode will use the
invokeDynamic code, the benefit being that the implementations can be enhanced in future java versions and the code
which is already compiled can benefit from this without having to recompile it. This being a big difference from what
happens when using data classes from Kotlin or Lombok.

The hashcode implementation is much faster in the JDK compared to Kotlin or Lombok data classes. For the equals, even
though there are more than one case, the Record still is the faster overall.

The advantage of having the validation rules in the constructor of a record is that you have the guarantee that it will
always be called because the canonical constructor is always called. This plays an important role when talking about
Serialization.

    class RangeLegacy implements Serializable {
        private final int begin;
        private final int end;
    }

Even if we put validations rules in this Constructor which does not allow begin to be higher than end in value, if we
had a corrupted serialized RangeLegacy object which was serialized with a begin higher than the end, this will be
deserialised bypassing the validation rule, leading to an application with an invalid instance.

For Records, this situation cannot happen, since the canonical constructor is always called. But how can we leverage
this without refactoring all our legacy code?

For the previous example of the RangeLegacy class, we can create a range record

    record Range(int begin, int end) implements Serializable {}

And we can write the writeReplace method in our RangeLegacy class, in order for it to be called when serializing

    class RangeLegacy implements Serializable {
        private final int begin;
        private final int end;

        @Serial
        private Object writeReplace() throws ObjectStreamException {
            return new Range(...);
        }
    }

Be careful that te method must return an Object and it must throw ObjectStreamException. After this method is created,
the serialized stream will contain Records instead of instances of your legacy RangeLegacy.

In order for the deserialization process to work we will need to implement te readResolve method in our record class

    record Range(int begin, int end) implements Serializable {
        
        @Serial 
        private Object readResolve() throws ObjectStreamException {
            return new RangeLegacy(...);
        }
    }

The deserialization process will first recreate the Record instance and then will call the canonical constructor, so no
more corrupted Records. Only after the deserialization process to the Range record finishes, because of the presence
of the readResolve method, they will be converted to instance of RangeLegacy by calling the correct constructor with 
the appropriate validation. 

So the cost of refactoring is not that large.